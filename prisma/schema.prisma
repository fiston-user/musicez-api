generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model SystemHealth {
  id        String   @id @default(uuid())
  status    String   @default("healthy")
  checkedAt DateTime @default(now())
  version   String   @default("1.0.0")

  @@map("system_health")
}

model ApiKey {
  id              String           @id @default(uuid())
  key             String           @unique
  name            String
  active          Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  lastUsed        DateTime?
  recommendations Recommendation[]

  @@index([key])
  @@map("api_keys")
}

model RequestLog {
  id         String   @id @default(uuid())
  method     String
  path       String
  statusCode Int
  duration   Int
  ip         String
  userAgent  String?
  createdAt  DateTime @default(now())

  @@index([createdAt])
  @@index([path])
  @@map("request_logs")
}

model User {
  id                 String              @id @default(uuid())
  email              String?             @unique
  password           String              @default("")
  name               String?
  emailVerified      Boolean             @default(false)
  lastLoginAt        DateTime?
  apiKeyId           String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  favoriteGenres     String[]
  recommendations    Recommendation[]
  preferences        UserPreference[]
  spotifyConnection  SpotifyConnection?
  spotifySyncJobs    SpotifySyncJob[]

  @@index([email])
  @@map("users")
}

model Song {
  id                    String            @id @default(uuid())
  spotifyId             String?           @unique
  title                 String
  artist                String
  album                 String?
  genre                 String?
  releaseYear           Int?
  tempo                 Float?
  key                   String?
  energy                Float?
  danceability          Float?
  valence               Float?
  acousticness          Float?
  instrumentalness      Float?
  popularity            Int?
  duration              Int?
  previewUrl            String?
  searchVector          String?           @db.Text
  
  // New Spotify integration fields
  spotifyLastSync       DateTime?
  spotifyPopularity     Int?
  spotifyPreviewUrl     String?
  spotifyExternalUrl    String?
  audioFeaturesSynced   Boolean           @default(false)
  lastPopularityUpdate  DateTime?
  speechiness           Float?
  liveness              Float?
  loudness              Float?
  
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  recommendations  Recommendation[]
  recommendedSongs RecommendedSong[]
  userPreferences  UserPreference[]

  @@index([spotifyId])
  @@index([artist])
  @@index([title])
  @@index([searchVector])
  @@index([spotifyLastSync, audioFeaturesSynced], map: "idx_songs_spotify_sync")
  @@index([spotifyPopularity], map: "idx_songs_spotify_popularity")
  @@map("songs")
}

model Recommendation {
  id               String            @id @default(uuid())
  userId           String?
  apiKeyId         String?
  inputSongId      String
  status           String            @default("pending")
  createdAt        DateTime          @default(now())
  completedAt      DateTime?
  processingTime   Int?
  apiKey           ApiKey?           @relation(fields: [apiKeyId], references: [id])
  inputSong        Song              @relation(fields: [inputSongId], references: [id])
  user             User?             @relation(fields: [userId], references: [id])
  recommendedSongs RecommendedSong[]

  @@index([userId])
  @@index([apiKeyId])
  @@index([status])
  @@index([createdAt])
  @@map("recommendations")
}

model RecommendedSong {
  id               String         @id @default(uuid())
  recommendationId String
  songId           String
  score            Float
  reason           String?
  position         Int
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  song             Song           @relation(fields: [songId], references: [id])

  @@unique([recommendationId, songId])
  @@index([recommendationId])
  @@map("recommended_songs")
}

model UserPreference {
  id        String   @id @default(uuid())
  userId    String
  songId    String
  rating    Int?
  liked     Boolean?
  skipped   Boolean  @default(false)
  playCount Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  song      Song     @relation(fields: [songId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, songId])
  @@index([userId])
  @@map("user_preferences")
}

model SpotifyConnection {
  id              String   @id @default(uuid())
  userId          String   @unique
  spotifyUserId   String   @unique
  accessToken     String
  refreshToken    String
  tokenExpiresAt  DateTime
  scope           String
  displayName     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("spotify_connections")
}

model SpotifySyncJob {
  id              String    @id @default(uuid())
  jobType         String
  status          String    @default("pending")
  targetId        String?
  parameters      Json?
  startedAt       DateTime?
  completedAt     DateTime?
  errorMessage    String?
  retryCount      Int       @default(0)
  itemsProcessed  Int       @default(0)
  totalItems      Int?
  userId          String
  createdAt       DateTime  @default(now())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status, createdAt], map: "idx_spotify_jobs_status")
  @@index([jobType, status], map: "idx_spotify_jobs_type")
  @@index([userId], map: "idx_spotify_jobs_user_id")
  @@map("spotify_sync_jobs")
}
